# Content Writer Scripts Implementation Plan

**Status:** ON HOLD - Pending Airtable automation design with Architect
**Created:** 2025-10-16
**Context:** Architectural change from Anthropic API to BMad Content Writer agent approach

---

## Background

This plan implements the TypeScript utility scripts discussed in the previous conversation to enable the BMad Content Writer agent to interact with Airtable for content generation.

**Key Architectural Decision:**
- MVP approach uses BMad Content Writer agent (via Claude Code) instead of Netlify Functions + Anthropic API
- Agent generates FAQ, Benefits, SEO Meta, and Hero Copy only
- Status-based filtering ensures only new pages are processed (Status = "AI Processing")
- Airtable automations handle Pages record creation
- Scripts provide programmatic interface between agent and Airtable

---

## Implementation Overview

### Files to Create (8 files)

1. **Type Definitions** - `src/types/content-writer.ts`
2. **Shared Utilities** - `scripts/content-writer/utils.ts`
3. **Fetch Script** - `scripts/content-writer/fetch-page-context.ts`
4. **Validation Script** - `scripts/content-writer/validate-generated-content.ts`
5. **Write Script** - `scripts/content-writer/write-to-airtable.ts`
6. **List Script** - `scripts/content-writer/list-pages-to-process.ts`
7. **Package.json Updates** - Add npm scripts
8. **Documentation** - `scripts/content-writer/README.md`

---

## Detailed File Specifications

### 1. Type Definitions (`src/types/content-writer.ts`)

**Purpose:** TypeScript interfaces for type safety across all scripts

```typescript
// Page context fetched from Airtable
export interface PageContext {
  recordId: string
  service: string
  location: string
  client: {
    name: string
    brandColor: string
    logoUrl: string
  }
  branch: {
    name: string
    phone: string
    email: string
    address: string
  }
  seoKeywords: string[]
  specialInstructions?: string
  status: string
}

// Content generated by agent
export interface GeneratedContent {
  recordId: string
  seoTitle: string // 50-60 chars
  seoMetaDescription: string // 150-160 chars
  h1Headline: string // 40-70 chars
  heroSubheadline: string // 80-120 chars
  faqs: Array<{
    question: string
    answer: string // 50-150 words
  }>
  benefits: Array<{
    title: string // 5-10 words
    description: string // 15-25 words
    icon: string // Icon name from approved list
  }>
}

// Validation report
export interface ValidationReport {
  valid: boolean
  errors: ValidationError[]
  warnings: ValidationWarning[]
}

interface ValidationError {
  field: string
  message: string
  severity: 'critical'
}

interface ValidationWarning {
  field: string
  message: string
  severity: 'warning'
}

// Airtable write payload
export interface AirtableWritePayload {
  fields: {
    'SEO Title': string
    'SEO Meta Description': string
    'H1 Headline': string
    'Hero Subheadline': string
    'FAQs': string // JSON.stringify(faqs)
    'Benefits': string // JSON.stringify(benefits)
    'Status': string // "Ready for Review"
  }
}
```

---

### 2. Shared Utilities (`scripts/content-writer/utils.ts`)

**Purpose:** Reusable functions for Airtable API operations

**Key Functions:**

```typescript
// Initialize Airtable HTTP client with auth
export function initAirtableClient(): {
  baseId: string
  apiKey: string
  baseUrl: string
}

// Centralized error handling
export function handleApiError(error: any): never

// Retry with exponential backoff (for rate limits)
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3
): Promise<T>

// Format field value for Airtable (JSON stringify arrays)
export function formatFieldValue(value: any): string | number | boolean

// Safe JSON parsing with error handling
export function parseJSONSafely<T>(json: string, fieldName: string): T
```

**Rate Limit Handling:**
- Airtable limit: 5 requests/second
- Exponential backoff: 1s, 2s, 4s, 8s
- Max 3 retries before failing

**Environment Variables:**
- Required: `AIRTABLE_API_KEY`, `AIRTABLE_BASE_ID`
- Fail fast if missing

---

### 3. Fetch Page Context Script (`scripts/content-writer/fetch-page-context.ts`)

**Purpose:** Pull page data from Airtable by record ID

**CLI Usage:**
```bash
npm run fetch-context rec1234567890ABC > page-context.json
```

**Implementation:**
```typescript
#!/usr/bin/env tsx

import { initAirtableClient, handleApiError } from './utils'
import type { PageContext } from '../../src/types/content-writer'

async function main() {
  const recordId = process.argv[2]

  if (!recordId) {
    console.error('Usage: npm run fetch-context <record-id>')
    process.exit(1)
  }

  const { baseId, apiKey, baseUrl } = initAirtableClient()

  // GET https://api.airtable.com/v0/{baseId}/Pages/{recordId}
  const response = await fetch(`${baseUrl}/Pages/${recordId}`, {
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    }
  })

  if (!response.ok) {
    handleApiError(await response.json())
  }

  const record = await response.json()

  // Transform to PageContext structure
  const context: PageContext = {
    recordId: record.id,
    service: record.fields['Service Name'],
    location: record.fields['Location Name'],
    client: {
      name: record.fields['Client Name (from Client)'][0],
      brandColor: record.fields['Brand Primary Color (from Client)'][0],
      logoUrl: record.fields['Logo URL (from Client)'][0]
    },
    branch: {
      name: record.fields['Branch Name (from Branch)'][0],
      phone: record.fields['Branch Phone (from Branch)'][0],
      email: record.fields['Branch Email (from Branch)'][0],
      address: record.fields['Branch Address (from Branch)'][0]
    },
    seoKeywords: record.fields['SEO Keywords'] || [],
    specialInstructions: record.fields['Special Instructions'],
    status: record.fields['Status']
  }

  // Output to stdout
  console.log(JSON.stringify(context, null, 2))
}

main().catch(handleApiError)
```

**Output:** JSON to stdout, errors to stderr
**Exit Codes:** 0 = success, 1 = error

---

### 4. Validation Script (`scripts/content-writer/validate-generated-content.ts`)

**Purpose:** Verify generated content meets quality standards

**CLI Usage:**
```bash
npm run validate-content < generated-content.json
npm run validate-content generated-content.json
```

**Validation Rules:**

**Critical Errors (fail validation):**
- Missing required fields
- Invalid JSON format
- SEO Title outside 50-60 chars
- SEO Meta Description outside 150-160 chars
- H1 Headline outside 40-70 chars
- Hero Subheadline outside 80-120 chars
- FAQs not array of 5 items
- Benefits not array of 5-7 items
- FAQ questions missing question marks
- Benefit icons not in approved list

**Warnings (don't fail validation):**
- FAQ answers outside 50-150 words
- Benefit titles outside 5-10 words
- Benefit descriptions outside 15-25 words
- Potential keyword stuffing (keyword appears >5 times)
- Placeholders detected (e.g., "[Client Name]", "[Service]")

**Implementation:**
```typescript
#!/usr/bin/env tsx

import { parseJSONSafely } from './utils'
import type { GeneratedContent, ValidationReport } from '../../src/types/content-writer'

const APPROVED_ICONS = [
  'award', 'shield', 'clock', 'dollar', 'star',
  'checkmark', 'wrench', 'home', 'phone', 'calendar'
]

async function main() {
  // Read from stdin or file
  let input: string
  if (process.argv[2]) {
    const fs = await import('fs/promises')
    input = await fs.readFile(process.argv[2], 'utf-8')
  } else {
    input = await readStdin()
  }

  const content = parseJSONSafely<GeneratedContent>(input, 'generated-content')
  const report = validateContent(content)

  console.log(JSON.stringify(report, null, 2))

  // Exit with error if validation failed
  if (!report.valid) {
    process.exit(1)
  }
}

function validateContent(content: GeneratedContent): ValidationReport {
  const errors: ValidationError[] = []
  const warnings: ValidationWarning[] = []

  // SEO Title validation
  if (content.seoTitle.length < 50 || content.seoTitle.length > 60) {
    errors.push({
      field: 'seoTitle',
      message: `Length ${content.seoTitle.length} outside 50-60 chars`,
      severity: 'critical'
    })
  }

  // SEO Meta Description validation
  if (content.seoMetaDescription.length < 150 || content.seoMetaDescription.length > 160) {
    errors.push({
      field: 'seoMetaDescription',
      message: `Length ${content.seoMetaDescription.length} outside 150-160 chars`,
      severity: 'critical'
    })
  }

  // H1 Headline validation
  if (content.h1Headline.length < 40 || content.h1Headline.length > 70) {
    errors.push({
      field: 'h1Headline',
      message: `Length ${content.h1Headline.length} outside 40-70 chars`,
      severity: 'critical'
    })
  }

  // Hero Subheadline validation
  if (content.heroSubheadline.length < 80 || content.heroSubheadline.length > 120) {
    errors.push({
      field: 'heroSubheadline',
      message: `Length ${content.heroSubheadline.length} outside 80-120 chars`,
      severity: 'critical'
    })
  }

  // FAQs validation
  if (!Array.isArray(content.faqs) || content.faqs.length !== 5) {
    errors.push({
      field: 'faqs',
      message: `Expected 5 FAQs, got ${content.faqs?.length || 0}`,
      severity: 'critical'
    })
  } else {
    content.faqs.forEach((faq, index) => {
      if (!faq.question.includes('?')) {
        errors.push({
          field: `faqs[${index}].question`,
          message: 'Question must end with question mark',
          severity: 'critical'
        })
      }

      const wordCount = faq.answer.split(/\s+/).length
      if (wordCount < 50 || wordCount > 150) {
        warnings.push({
          field: `faqs[${index}].answer`,
          message: `Word count ${wordCount} outside recommended 50-150 words`,
          severity: 'warning'
        })
      }
    })
  }

  // Benefits validation
  if (!Array.isArray(content.benefits) || content.benefits.length < 5 || content.benefits.length > 7) {
    errors.push({
      field: 'benefits',
      message: `Expected 5-7 benefits, got ${content.benefits?.length || 0}`,
      severity: 'critical'
    })
  } else {
    content.benefits.forEach((benefit, index) => {
      if (!APPROVED_ICONS.includes(benefit.icon)) {
        errors.push({
          field: `benefits[${index}].icon`,
          message: `Icon "${benefit.icon}" not in approved list`,
          severity: 'critical'
        })
      }
    })
  }

  // Check for placeholders
  const allText = JSON.stringify(content)
  if (allText.includes('[') && allText.includes(']')) {
    warnings.push({
      field: 'content',
      message: 'Possible placeholder detected (text contains brackets)',
      severity: 'warning'
    })
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings
  }
}

main()
```

**Output:** ValidationReport JSON to stdout
**Exit Codes:** 0 = valid (warnings OK), 1 = invalid (errors present)

---

### 5. Write to Airtable Script (`scripts/content-writer/write-to-airtable.ts`)

**Purpose:** Upload generated content back to Airtable

**CLI Usage:**
```bash
npm run write-content rec1234567890ABC generated-content.json
```

**Implementation:**
```typescript
#!/usr/bin/env tsx

import { initAirtableClient, handleApiError, retryWithBackoff, formatFieldValue } from './utils'
import type { GeneratedContent, AirtableWritePayload } from '../../src/types/content-writer'
import fs from 'fs/promises'

async function main() {
  const recordId = process.argv[2]
  const contentFile = process.argv[3]

  if (!recordId || !contentFile) {
    console.error('Usage: npm run write-content <record-id> <content-file>')
    process.exit(1)
  }

  const { baseId, apiKey, baseUrl } = initAirtableClient()

  // Read generated content
  const contentJson = await fs.readFile(contentFile, 'utf-8')
  const content: GeneratedContent = JSON.parse(contentJson)

  // Transform to Airtable payload
  const payload: AirtableWritePayload = {
    fields: {
      'SEO Title': content.seoTitle,
      'SEO Meta Description': content.seoMetaDescription,
      'H1 Headline': content.h1Headline,
      'Hero Subheadline': content.heroSubheadline,
      'FAQs': JSON.stringify(content.faqs), // Array → JSON string
      'Benefits': JSON.stringify(content.benefits), // Array → JSON string
      'Status': 'Ready for Review' // Update status
    }
  }

  // PATCH with retry logic
  const updateRecord = async () => {
    const response = await fetch(`${baseUrl}/Pages/${recordId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    })

    if (!response.ok) {
      const error = await response.json()
      if (response.status === 429) {
        // Rate limit - will retry
        throw new Error('RATE_LIMIT')
      }
      handleApiError(error)
    }

    return response.json()
  }

  // Execute with retry
  const result = await retryWithBackoff(updateRecord)

  console.log('✅ Content written to Airtable successfully')
  console.log(`   Record ID: ${result.id}`)
  console.log(`   Status: ${result.fields['Status']}`)
}

main().catch(handleApiError)
```

**Features:**
- JSON stringification for array fields (FAQs, Benefits)
- Automatic status update to "Ready for Review"
- Retry logic for rate limits (exponential backoff)
- Clear success message with record confirmation

**Output:** Success message to stdout
**Exit Codes:** 0 = success, 1 = error

---

### 6. List Pages Script (`scripts/content-writer/list-pages-to-process.ts`)

**Purpose:** Query pages that need AI processing

**CLI Usage:**
```bash
npm run list-pages-to-process
```

**Implementation:**
```typescript
#!/usr/bin/env tsx

import { initAirtableClient, handleApiError } from './utils'

async function main() {
  const { baseId, apiKey, baseUrl } = initAirtableClient()

  // Build filter formula for Status = "AI Processing"
  const filterFormula = encodeURIComponent('{Status} = "AI Processing"')

  // GET with filter
  const response = await fetch(
    `${baseUrl}/Pages?filterByFormula=${filterFormula}&fields[]=Service Name&fields[]=Location Name&fields[]=Client Name (from Client)&fields[]=Status`,
    {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    }
  )

  if (!response.ok) {
    handleApiError(await response.json())
  }

  const data = await response.json()
  const records = data.records

  if (records.length === 0) {
    console.log('No pages found with Status = "AI Processing"')
    return
  }

  console.log(`Found ${records.length} page(s) to process:\n`)

  records.forEach((record: any, index: number) => {
    console.log(`${index + 1}. Record ID: ${record.id}`)
    console.log(`   Service: ${record.fields['Service Name']}`)
    console.log(`   Location: ${record.fields['Location Name']}`)
    console.log(`   Client: ${record.fields['Client Name (from Client)'][0]}`)
    console.log('')
  })
}

main().catch(handleApiError)
```

**Features:**
- Filters by Status = "AI Processing" only
- Returns minimal fields for quick preview
- Clear formatting with numbered list
- Shows count of pages to process

**Output:** Formatted list to stdout
**Exit Codes:** 0 = success, 1 = error

---

### 7. Package.json Updates

**Add npm scripts:**

```json
{
  "scripts": {
    "fetch-context": "tsx scripts/content-writer/fetch-page-context.ts",
    "validate-content": "tsx scripts/content-writer/validate-generated-content.ts",
    "write-content": "tsx scripts/content-writer/write-to-airtable.ts",
    "list-pages-to-process": "tsx scripts/content-writer/list-pages-to-process.ts"
  }
}
```

**Dependencies:**
- `tsx` - Already installed (TypeScript execution)
- `dotenv` - Already installed (environment variables)

---

### 8. Documentation (`scripts/content-writer/README.md`)

**Contents:**
- Overview of script workflow
- Installation instructions (already installed with project)
- Usage examples for each script
- Environment variable requirements
- Troubleshooting guide (rate limits, authentication errors)
- Integration with BMad agent workflow

---

## Complete Workflow Example

### 1. List pages that need processing
```bash
npm run list-pages-to-process
```

**Output:**
```
Found 2 page(s) to process:

1. Record ID: rec1234567890ABC
   Service: Bathroom Remodeling
   Location: Austin, TX
   Client: BathroomPros

2. Record ID: recXYZ9876543210
   Service: Kitchen Remodeling
   Location: Dallas, TX
   Client: KitchenExperts
```

### 2. Fetch page context
```bash
npm run fetch-context rec1234567890ABC > page-context.json
```

**Output (page-context.json):**
```json
{
  "recordId": "rec1234567890ABC",
  "service": "Bathroom Remodeling",
  "location": "Austin, TX",
  "client": {
    "name": "BathroomPros",
    "brandColor": "#0066cc",
    "logoUrl": "https://example.com/logo.png"
  },
  "branch": {
    "name": "Austin North",
    "phone": "(512) 555-1234",
    "email": "austin@bathrooompros.com",
    "address": "123 Main St, Austin, TX 78701"
  },
  "seoKeywords": ["bathroom remodeling austin", "austin bathroom contractor"],
  "specialInstructions": "Emphasize fast turnaround (7-10 days)",
  "status": "AI Processing"
}
```

### 3. Agent generates content (manual step)
```bash
# In Claude Code:
/BMad:agents:copywriter
*generate-full-page rec1234567890ABC
```

**Agent workflow:**
1. Reads page-context.json
2. Generates FAQ using task workflow
3. Generates Benefits using task workflow
4. Generates SEO Meta using task workflow
5. Generates Hero Copy using task workflow
6. Combines into generated-content.json

**Output (generated-content.json):**
```json
{
  "recordId": "rec1234567890ABC",
  "seoTitle": "Bathroom Remodeling in Austin, TX | Free Quote",
  "seoMetaDescription": "Transform your bathroom with Austin's trusted experts. 25+ years experience, A+ BBB rated, lifetime warranty. Free quotes - call today!",
  "h1Headline": "Expert Bathroom Remodeling in Austin, TX",
  "heroSubheadline": "Transform your bathroom into the space you've always dreamed of. 25+ years of trusted Austin service. Free quotes available.",
  "faqs": [
    {
      "question": "How much does bathroom remodeling cost in Austin, TX?",
      "answer": "Bathroom remodeling in Austin typically ranges from $8,000 to $25,000..."
    }
    // ... 4 more FAQs
  ],
  "benefits": [
    {
      "title": "25+ Years of Austin Expertise",
      "description": "Trust a local company that's transformed over 5,000 bathrooms across Austin.",
      "icon": "award"
    }
    // ... 4-6 more benefits
  ]
}
```

### 4. Validate generated content
```bash
npm run validate-content generated-content.json
```

**Output (if valid):**
```json
{
  "valid": true,
  "errors": [],
  "warnings": [
    {
      "field": "faqs[2].answer",
      "message": "Word count 47 outside recommended 50-150 words",
      "severity": "warning"
    }
  ]
}
```

**Exit code:** 0 (success - warnings don't fail validation)

### 5. Write to Airtable
```bash
npm run write-content rec1234567890ABC generated-content.json
```

**Output:**
```
✅ Content written to Airtable successfully
   Record ID: rec1234567890ABC
   Status: Ready for Review
```

**Exit code:** 0 (success)

### 6. Marketing reviews in Airtable
- Marketing opens Airtable
- Sees page with Status = "Ready for Review"
- Reviews generated content (SEO Title, FAQs, Benefits, etc.)
- Approves → Changes Status to "Approved"

### 7. Automated deployment
- Airtable webhook fires on Status change
- GitHub Actions exports approved pages to content.json
- Netlify builds and deploys

---

## Integration with BMad Agent

### Master Workflow Task Updates

**File:** `.bmad-core/tasks/generate-landing-page-content.md`

**Add script integration steps:**

```markdown
## Step 2: Load Page Data from Airtable

Run the fetch script to pull page context:

```bash
npm run fetch-context {record_id} > page-context.json
```

This creates a JSON file with all necessary data for content generation.

## Step 10: Validate Generated Content

Before writing to Airtable, validate the content:

```bash
npm run validate-content generated-content.json
```

If validation fails (errors present), review the error report and regenerate content.

If validation passes (warnings OK), proceed to Step 11.

## Step 11: Write Content to Airtable

Upload the validated content:

```bash
npm run write-content {record_id} generated-content.json
```

This updates the Airtable record and sets Status = "Ready for Review".
```

---

## Error Handling & Edge Cases

### 1. Missing Environment Variables
**Error:** `AIRTABLE_API_KEY not found in environment`
**Solution:** Create `.env.local` file with required variables

### 2. Rate Limit Exceeded
**Error:** `429 Too Many Requests`
**Solution:** Scripts automatically retry with exponential backoff (3 attempts)

### 3. Invalid Record ID
**Error:** `Record not found`
**Solution:** Verify record ID exists in Airtable Pages table

### 4. Validation Failure
**Error:** Validation reports critical errors
**Solution:** Review error report, adjust content, re-validate

### 5. Network Timeout
**Error:** `ECONNREFUSED` or `ETIMEDOUT`
**Solution:** Check internet connection, verify Airtable API status

---

## Testing Strategy

### Unit Tests (Future)
- Test utility functions (formatFieldValue, parseJSONSafely)
- Test validation logic with fixture data
- Mock Airtable API responses

### Integration Tests (Future)
- Test complete workflow with Airtable test base
- Verify status transitions
- Test error handling and retries

### Manual Testing (MVP)
1. Run scripts with test record ID
2. Verify output format matches expectations
3. Check Airtable record updates correctly
4. Test validation with intentionally bad data

---

## Dependencies with Airtable Automations

**BLOCKED:** This implementation is blocked pending Airtable automation design with Architect.

**Key Questions for Architect:**

1. **Pages Record Creation:**
   - How are Pages records generated? (Automation or manual?)
   - What triggers record creation? (Keyword list update? Manual button?)
   - What is the initial Status value? ("Draft" or "AI Processing"?)

2. **Status Transitions:**
   - Draft → AI Processing: Manual or automated?
   - Ready for Review → Approved: Manual only?
   - Approved → Published: Automated on export?

3. **Webhook Configuration:**
   - What Status change triggers webhook?
   - What data is sent to GitHub Actions?
   - How to handle webhook failures?

4. **Lookup Field Dependencies:**
   - Are all HIGH priority lookup fields configured?
   - Are Client, Service, Branch tables populated?
   - Do we need fallback values for missing lookups?

5. **Batch Processing:**
   - Should scripts support batch mode (process all "AI Processing" pages)?
   - Should there be a rate limit buffer between batch items?
   - How to handle partial failures in batch mode?

---

## Next Steps

### Immediate (After Airtable Automation Design)
1. Create all 8 files per specifications above
2. Test scripts with Airtable test base
3. Update BMad agent workflows to integrate scripts
4. Document troubleshooting for common errors

### Short-term
1. Create batch processing script
2. Add logging/telemetry for debugging
3. Create integration tests
4. Update PRD with final workflow

### Long-term (Post-MVP)
1. Convert agent workflows to Netlify Functions
2. Add automated triggers (no manual agent invocation)
3. Implement monitoring/alerting
4. Add content quality metrics/analytics

---

## PRD Updates Required

**Files to update after implementation:**

1. **`docs/PRD.md`** - Update Epic 8 (AI Content Generation)
   - Change from "Netlify Functions + Claude API" to "BMad Agent + Scripts"
   - Update workflow diagram
   - Update cost estimates ($0 for MVP)

2. **`docs/workflows/ongoing/content-creation-workflow.md`** - Already updated

3. **`docs/architecture/tech-stack.md`** - Already updated

4. **`docs/architecture/external-services-apis.md`**
   - Add Airtable REST API section
   - Document authentication, rate limits, error codes

5. **`docs/components/component-data-contracts.md`**
   - Confirm FAQ and Benefits JSON structure matches script output

6. **`docs/PROJECT-STATUS.md`**
   - Update Epic 8 status once scripts are implemented

---

## File Checklist

- [ ] `src/types/content-writer.ts` - Type definitions
- [ ] `scripts/content-writer/utils.ts` - Shared utilities
- [ ] `scripts/content-writer/fetch-page-context.ts` - Fetch script
- [ ] `scripts/content-writer/validate-generated-content.ts` - Validation script
- [ ] `scripts/content-writer/write-to-airtable.ts` - Write script
- [ ] `scripts/content-writer/list-pages-to-process.ts` - List script
- [ ] `package.json` - npm scripts added
- [ ] `scripts/content-writer/README.md` - Documentation
- [ ] BMad agent workflow updates - Script integration
- [ ] Integration testing with Airtable test base
- [ ] PRD updates (6 files)

---

**Status:** Ready to implement after Airtable automation design complete
**Owner:** Dev Agent
**Duration:** 4-6 hours
**Dependencies:** Architect must define Airtable automation workflows first
